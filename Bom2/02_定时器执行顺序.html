<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta name="Author" content="">
    <meta name="Keywords" content="">
    <meta name="Description" content="">
    <script>
        /*  定时器的回调函数，必须等待主程序执行完毕后才能执行
            如果主程序没有执行完，或被阻塞，定时器的回调函数永远无法执行！
        * */
        /*function task(){
            console.log("起床啦");
        }
        var timer=null;
        timer=setTimeout(task,1000);
        alert(1);*/
    //    a. 1  起床啦    b.  起床啦   1

        /*for(var i=0;i<3;i++){
            setTimeout(function(){
                console.log(i);
            },1);
        }*/
    //    a. 0 1 2    b. 1 1 1   c. 1 2 3  d. 3 3 3
        /*  每次for循环的时候，setTimeout都执行一次，但是里面的回调函数没有被执行
            被放到任务队列里面，等待执行，for循环3次后，队列里就放了3次，
            当主程序执行完成后，才进入任务队列里进行执行！
        *
        * */

        for(let i=0;i<3;i++){
            setTimeout(function(){
                console.log(i);
            },1000)
        }
        //因为for循环头部的let不仅将i绑定到for循环快中，事实上它将其重新绑定到循环体的每一次迭代中确保上一次迭代结束的值重新被赋值。
        // setTimeout里面的function()属于一个新的域，通过 var 定义的变量是无法传入到这个函数执行域中的，通过使用 let 来声明块变量，
        // 这时候变量就能作用于这个块，所以 function就能使用 i 这个变量了；这个匿名函数的参数作用域 和 for参数的作用域 不一样，
        // 是利用了这一点来完成的。这个匿名函数的作用域有点类似类的属性，是可以被内层方法使用的。打印出的是：0,1,2


    </script>
</head>
<body>

</body>
</html>