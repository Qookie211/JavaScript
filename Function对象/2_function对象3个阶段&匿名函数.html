<!DOCTYPE html>
<html>
<head>
    <title> new document </title>
    <meta charset="utf-8" />
    <script>
		/*	***内存中的函数对象：3个阶段
				1. 定义时 创建2个对象 - 函数对象和*作用域链对象*
				   函数对象：封装了函数的定义，但是不读取函数的内容
				   **作用域链对象：专门保存了函数可用的变量所在的位置的对象
				2. 调用时：创建一个对象 - 活动对象
					活动对象：临时封装本次调用函数时使用的局部变量
					         并将活动对象的应用，压入作用域链对象中
				3. 调用后：作用域链中的活动对象引用出栈
				          活动对象连同内部的局部变量一同释放！

			***如何创建函数对象：3种方式
			1. 声明方式：function 函数名(){}
			 ****只有声明方式的函数对象是被提前的
			2. 函数直接量方式
			   var fun=function(){}
			3. new Function:
			   var 函数名=new Function("参数1","参数2",....,"函数体");


		    ***匿名函数：定义时，没有变量引用的函数
		       何时使用：
		       	1. 匿名函数的自调：定义完立即执行，执行完毕立刻释放
		       	   一个匿名函数只能用一次！
		       	   (function(参数列表){
		       	   		函数体;
		       	   		return 返回值;
		       	   })(参数值列表)

		       	2. 回调函数：将函数作为对象传递给其他函数使用
					arr.sort() --> 先创建比较器函数
					function compareUp(a,b){return a-b}
					arr.sort(compareUp)

		       		arr.sort(function(a,b){return a-b});
		       优点：节省内存空间
		       缺点：不能反复使用
		*
		* */

		/*var n=5;
		function fun(n){
			n--;
			console.log(n);
		}
		fun(n);// 4
		console.log(n);// 5*/

		var n=5;
		(function(n){
			n--;
			console.log(n);
		})(n);
		console.log(n);
    </script>
</head>

<body>
	<script>

	</script>
	<h1>Eric</h1>
	<h1>Smith</h1>
	<h1>Tom</h1>
	<h1>Jerry</h1>
	<script>

	</script>
</body>
</html>
